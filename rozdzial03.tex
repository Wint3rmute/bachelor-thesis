\chapter{ Architektura systemu: przegląd i wybór technologii }

\section{Zarys architektury}

% \begin{tikzpicture}[auto,node distance=1.5cm]
% 	% Create an entity with ID node1, label "Fancy Node 1".
% 	% Default for children (ie. attributes) is to be a tree "growing up"
% 	% and having a distance of 3cm.
% 	%
% 	% 2 of these attributes do so, the 3rd's positioning is overridden.
% 	\node[entity] (backend) {\textbf{Serwer webowy}}
% 	  [grow=up,sibling distance=1cm];

% 	  \node[entity, node distance=0.5cm] (telem) [below  = of backend] {\footnotesize{Obsługa telemetrii}};
% 	  \node[entity, node distance=0.5cm, align=center] (api) [below right = of backend] {\footnotesize{Zapis tras i harmonogramu lotów}};
% 	  \node[entity, node distance=0.5cm] (api) [below left = of backend] {\footnotesize{Archiwizacja logów}};
% 	% Now place a relation (ID=rel1)
% 	% Now the 2nd entity (ID=rel2)
% 	\node[entity, node distance=3cm] (dron) [below left = of backend] {Dron};
% 	% \path (dron) edge node {n-\(1\)} (backend);

% 	\node[entity, node distance=2.5cm] (flight_controller) [ below left of = dron] {Kontroler lotu};
% 	\node[entity, node distance=2.5cm] (flight_computer) [ below right of = dron] {Komputer pokładowy};
% 	\node[entity, node distance=1.5cm] (camera) [ below of = flight_computer] {Kamera};

% 	\node[entity, node distance=3cm] (frontend) [below right = of backend] {Aplikacja kliencka};
% 	% \path (backend) edge node {1-\(n\)} (frontend);




% \end{tikzpicture}
% \begin{tikzpicture} [level distance=2cm] %[level 1/.style={sibling distance=2cm},level 2/.style={sibling distance=10mm}]


% 	\tikzstyle{level 1}=[sibling distance=4.5cm]
% 	\tikzstyle{level 2}=[sibling distance=3.5cm]
% 	\tikzstyle{level 3}=[sibling distance=2mm]
		
% 	\node[](root){}
% 		child {node [rectangle,draw] (dron) {Dron}
% 			edge from parent[draw=none]
% 			child {node [rectangle,draw](flight_controller){Kontroler lotu}}
% 			child {node [rectangle,draw](flight_computer){Komputer pokładowy}
% 				child {node [rectangle,draw, yshift=1.1cm](camera){Kamera}}
% 			}
% 		}
% 		child {node [rectangle,draw, yshift=1.5cm, xshift=-0.5cm] (backend) {Serwer webowy}
% 			edge from parent[draw=none]
% 			child {node [rectangle,draw](flight_controller){Rest API}}
% 			child {node [rectangle,draw, align=center](ai){Analiza\\zdjęć}}
% 			child {node [rectangle,draw, align=center](flight_controller){Obsługa\\telemetrii}}
% 		}
% 		child {node [rectangle,draw] (frontend) {Aplikacja kliencka}
% 			edge from parent[draw=none]
% 			child {node [rectangle,draw, align=center](flight_controller){Odbiór\\telemetrii}}
% 			child {node [rectangle,draw, align=center](flight_controller){Planowanie tras i \\ harmonogramów lotów}}
% 		};
		

% \end{tikzpicture}

\begin{figure}[H]
\centering\small
\caption{
	Zarys architektury systemu
}
\label{fig}
\hspace{-1.2cm}
\begin{forest}
	% forest preamble: determine layout and format of tree
	direction switch,
	for tree={fork sep=3em}
	[ System inspekcji obszarów,yshift=3em,alias=LP
	  [ \textbf{Dron}
		[ Kontroler lotu ]
		[ Komputer pokładowy
		 [ Wyznaczanie trasy lotu ]
		 [ Wysyłanie telemetrii ]
		 [ Wysyłanie zdjęć ]
		]
		[ Kamera ]
		[ Modem GSM ]
	  ]
	  [ \textbf{Serwer webowy}, yshift=0.5cm
		[ Obsługa telemetrii
			[ Odbiór danych z drona ]
			[ Przekazywanie do klientów ]
			[ Przygotowanie do archiwizacji ]
		]
		[ Rest API: odczyt i zapis
		  [ Logów telemetrii ]
		  [ Tras lotów ] 
		  [ Harmonogramu lotów ]
		  [ Raportów z lotów ]
		]
		[ Sztuczna inteligencja
		  [ Analiza obrazów z lotów ]
		]
	  ]
	  [ \textbf{Aplikacja kliencka}, xshift=0.1cm
		[ Planowanie 
			[ Tras lotów ]
			[ Harmonogramu lotów ]
		]
		[ Odbiór telemetrii ]
		[ Przegląd raportów z lotów 
		  [ Trasa lotu ]
		  [ Rozpoznane na zdjęciach obiekty ]
		]
	  ]
	]
%   \draw[thick]
%   ([yshift=-1.5em]LP.south)  -- ++(-6em,0) node[left,draw,font=\sffamily,thin]{ABC}
%   ([yshift=-1.5em]LP.south)  -- ++(6em,0) node[right,draw,font=\sffamily,thin]{XYZ};
  \end{forest}
\end{figure}

% \begin{tikzpicture}
	
% 	\node[entity](backend) {Serwer webowy}
% 	[];
% 	\node[entity](backend_telem) {Podsystem obsługujący telemetrię}[
% 		below right = of backend
% 	];

% 	% \node[entity] (dron) {Dron}
% 	%   [grow=up,sibling distance=3cm];
	
	
	 
% \end{tikzpicture}

\section{Dron}

\subsection{Kontroler lotu}

Wielowirnikowce podłączone do systemu, muszą być
wyposażone w kontroler lotu -- umożliwiający
autonomiczny lot, stabilizację oraz obsługę 
peryferiów takich jak czujniki oraz silniki.

Spośród aktywnie rozwijanych i popularnych
projektów \cite{autopilots_sourvey} tworzących oprogramowanie do kontrolerów
lotu, można wyróżnić cztery najpopularniejsze inicjatywy: 

\begin{table}[htb]
	\centering\small
	\caption{
		Najpopularniejsze otwarte projekty
		oprogramowania obsługującego kontrolery lotu
	}
	\label{tab}

	\begin{tabularx}{0.87\textwidth}
	{ 
	| >{\raggedright\arraybackslash}l 
	| c 
	| >{\raggedright\arraybackslash}X
	| >{\raggedleft\arraybackslash}l |
	}
	\hline
	\textbf{Nazwa projektu} & \textbf{Rok założenia} &
	\textbf{Docelowy hardware}
	&  \textbf{Licencja}
	\\\hline
	ArduPilot\cite{ardupilot_home_page}		&  2009	& otwarte mikrokontrolery ARM & GPLv3
	\\ \hline
	AutoQuad\cite{autoquad_timeline}		&  2011	& mikrokontrolery STM Cortex M4		 & GPLv3
	\\ \hline
	LibrePilot\cite{librepilot_home_page}	&  2015	& zamknięte źródłowo kontrolery lotu, bazujące na architekturze ARM & GPLv3
	\\ \hline       
	PX4 Autopilot\cite{px4_home_page}		&  2012	& otwarte mikrokontrolery ARM & BSD
	\\ \hline       
	\end{tabularx}
	
\end{table}

Spośród wymienionych projektów, ArduPilot posiada najbardziej rozbudowaną bazę 
dokumentacji i instrukcji. Architektura projektu umożliwia skompilowanie projektu
na standardowy komputer typu PC uruchomienie go w wirtualnym
środowisku\cite{ardupilot_sitl}, co ułatwia proces testowania oprogramowania,
które steruje dronem -- model maszyny jest symulowany, jednak warstwa komunikacji
jest dokładnie taka sama, jak w przypadku pracy z prawdziwym dronem. Dodatkowo, projekt
realizowany był w kole studenckim, w którym ArduPilot jest od lat wykorzystywany
do sterowania dronami i samolotami, co przesądziło o zastosowaniu go jako
oprogramowanie do kontrolera lotu.

\subsection{Komputer pokładowy}

Poza kontrolerem lotu, który zawiera jedynie oprogramowanie 
niezbędnie do sterowania dronem i udostępniania
strumienia telemetriii, na maszynie musi znaleźć się też komputer pokładowy, 
do zastosowań bardziej ogólnych. Będzie on wykorzystywany do
obsługi wysokopoziomowych peryferiów: kamery oraz modemu GSM. Do zadań
komputera pokładowego będzie należała także realizacja logiki biznesowej systemu
- odczytanie harmonogramu przelotów z serwera webowego i załadowanie do kontrolera lotu
konkretnej trasy przelotu.

\subsubsection{Wymagania sprzętowe}

Aby wypełniać zadania wymienione powyżej, komputer pokładowy musi
posiadać następujące interfejsy sprzętowe:

\begin{itemize}
	\item \texttt{UART} -- do komunikacji z kontrolerem lotu,
	\item \texttt{USB} -- do komunikacji z modemem,
	\item \texttt{CSI} -- do komunikacji z kamerą.
\end{itemize}

Większość dostępnych na rynku komputerów klasy SBC (\textit{Single-board Computer})
posiada powyższe interfejsy, więc wymagania sprzętowe nie są tutaj ograniczeniem.
W projekcie został wykorzystany najpopularniejszy do zastosowań amatorskich
komputer \textit{Raspberry Pi}. 

\subsubsection{Oprogramowanie}

Na komputerze pokładowym zainstalowany jest system Linux -- gwarantuje to bezproblemową
obsługę peryferiów oraz dostępność stosu sieciowego, koniecznego do przesyłania 
danych telemetrycznych i zdjęć.
Dodatkowo, wymagane jest oprogramowanie dekodujące
i enkodujące wiadomości protokołu \textit{MavLink}, który jest wykorzystywany przez 
ArduPilota do komunikacji z zewnętrznymi systemami \cite{ardupilot_mavlink}.

Infrastruktura projektu ArduPilot dostarcza gotowe biblioteki, służące do
parsowania i tworzenia wiadomości w protokole \textit{MavLink}. Wykorzystujemy bibliotekę
\textit{Dronekit-Python}, która rozszerza biblioteki dostarczane przez projekt
\textit{ArduPilot} i udostępnia interfejs obiektowy do komunikacji z kontrolerem lotu.

\section{Protokoły wymiany danych}

\section{Oprogramowanie serwerowe}

\section{Oprogramowanie klienckie}

\section{Struktura repozytoriów}

% \section{Praca z wieloma repozytoriami}
\section{Wspólne punkty stykowe - \texttt{git submodules}}


\section{Podsumowanie architektury}

% \chapter{Metodyka pracy i zarządzania}
% \section{Efektywne wykorzystanie narzędzi dostępnych w popularnych 
% systemach kontroli wersji}
